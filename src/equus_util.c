/**
*  Copyright 2012 Rackspace
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
 */

#include <stdarg.h>
#include <stdlib.h>
#include "equus_util.h"
#include "equus_pubkey.h"

#ifdef _WIN32
static CRITICAL_SECTION resmtx;
#ifdef _MSC_VER
#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
#include <psapi.h>
#include <stdlib.h>
#include <crtdbg.h>
#include <errno.h>
#endif
#endif
#else
static pthread_mutex_t resmtx = PTHREAD_MUTEX_INITIALIZER;
#endif


static int global_argc = 0;
static char **global_argv = NULL;
equus_conf_t *global_conf = NULL;

void equus_set_argv(int argc, char* argv[])
{
  global_argc = argc;
  global_argv = argv;
}

int equus_get_argc()
{
  return global_argc;
}

const char* equus_get_argv(int offset)
{
  if (offset > global_argc || global_argv == NULL) {
    return NULL;
  }

  return global_argv[offset];
}


/* Verification of Signatures generated by a Public Key.
 * */
#include <openssl/err.h>
#include <openssl/ssl.h>
#include <openssl/evp.h>

static void equus_util_atexit(void)
{
  if (global_conf != NULL)
  {
    equus_conf_free(global_conf);
  }

  ERR_free_strings();
  EVP_cleanup();
  CRYPTO_cleanup_all_ex_data();
#ifdef _WIN32
  DeleteCriticalSection(&resmtx);
#endif
}

static void equus_verify_init()
{
  SSL_load_error_strings();
  SSL_library_init();
  OpenSSL_add_all_ciphers();
  OpenSSL_add_all_digests();
  OpenSSL_add_all_algorithms();

  atexit(equus_util_atexit);
}

static int is_help_switch_present()
{
  int i;
  for (i = 1; i < equus_get_argc(); i++)
  {
    if (strcmp(equus_get_argv(i), "-h") == 0 ||
        strcmp(equus_get_argv(i), "--help") == 0)
    {
      return 1;
    }
  }

  return 0;
}

void equus_loader_init();
int equus_util_init()
{
#ifdef _WIN32
  InitializeCriticalSection(&resmtx);
#endif
  equus_verify_init();
  equus_loader_init();

  if (is_help_switch_present() == 1)
  {
    return 0;
  }

  return equus_load_config();
}

int equus_load_config()
{
  int rv;
  equus_conf_t *conf_old = NULL;
  equus_conf_t *conf_new = NULL;

  if (global_conf != NULL)
  {
    conf_old = global_conf;

    conf_new  = calloc(1, sizeof(equus_conf_t));
    rv = equus_conf_init(conf_new);

    global_conf = conf_new;
    equus_conf_free(conf_old);
  }
  else
  {
    global_conf = calloc(1, sizeof(equus_conf_t));

    rv = equus_conf_init(global_conf);
  }

  return rv;
}

int equus_verify(const char *input, int len,
                 const char *sigbuf, int siglen,
                 const char *keybuf, int keylen)
{
  int rv = 0;
  EVP_MD_CTX mdctx;
  const EVP_MD *md = EVP_sha1();
  EVP_PKEY *pubkey = NULL;
  BIO *mem;
  if (keylen == 0 || keybuf == NULL) {
    size_t len;
    equus_pubkey_get(&keybuf, &len);
    keylen = len;
  }

  mem = BIO_new_mem_buf((void*)keybuf, keylen);

  pubkey = PEM_read_bio_PUBKEY(mem, NULL, NULL, NULL);
  if (pubkey == NULL) {
    abort();
  }

  EVP_MD_CTX_init(&mdctx);
  EVP_VerifyInit_ex(&mdctx, md, NULL);
  EVP_VerifyUpdate(&mdctx, input, len);
  rv = EVP_VerifyFinal(&mdctx, (unsigned const char*)sigbuf, siglen, pubkey);
  EVP_MD_CTX_cleanup(&mdctx);
  EVP_PKEY_free(pubkey);
  BIO_free(mem);

  if (rv == 1) {
    /** READ YOUR OPENSSL DOCUMENTATION:
     * EVP_VerifyFinal() returns 1 for a correct signature, 0 for failure
     * and -1 if some other error occurred.
     */
    return 0;
  }
  else {
    return -1;
  }
}


const char *equus_url()
{
#ifdef EQUUS_BOOTSTRAP_URL
  if (global_conf == NULL) {
      return EQUUS_BOOTSTRAP_URL;
  }
#endif
  return global_conf->resources;
}


#ifdef _WIN32
//#define USE_EVENT_LOG
#endif

static equus_log_level_e g_equus_log_level = EQUUS_LOG_EVERYTHING;
#ifdef USE_EVENT_LOG
static HANDLE g_equus_log_handle = NULL;
#endif
static FILE* g_equus_log_fp = NULL;
static const char *g_equus_log_path = NULL;

int equus_log_rotate()
{
  FILE *old = g_equus_log_fp;
  FILE *nxt = stderr;

#ifdef USE_EVENT_LOG
  if (g_equus_win_service) {
    equus_log(EQUUS_LOG_INFO, "Logging started...");
    return 0;
  }
#endif

  if (g_equus_log_path != NULL) {
    nxt = fopen(g_equus_log_path, "ab");
    if (nxt == NULL) {
      char buf[256];
      int err = errno;
#ifdef _WIN32
      strncpy(&buf[0], strerror(err), sizeof(buf));
#else
      strerror_r(err, &buf[0], sizeof(buf));
#endif
      logCrit("Failed to open log file: %s (errno=%d,%s)", g_equus_log_path,
              err, &buf[0]);
      return 1;
    }
  }

  g_equus_log_fp = nxt;

  if (old != NULL && old != stderr) {
    fclose(old);
  }
  equus_log(EQUUS_LOG_INFO, "Log file started...");

  return 0;
}

int equus_log_set_path(const char *path)
{
  char *oldstr = (char*)g_equus_log_path;

#ifdef USE_EVENT_LOG
  if (g_equus_win_service) {
    return 0;
  }
#endif

  if ((path == NULL || (strcmp(path, "-") == 0)) &&
      g_equus_log_fp != stderr) {
    FILE *oldfp = g_equus_log_fp;
    g_equus_log_fp = stderr;
    if (oldfp != NULL)
      fclose(oldfp);
  }
  else if ((path == NULL || (strcmp(path, "-") == 0)) &&
           g_equus_log_fp == stderr) {
    /*noop*/
  }
  else {
    char *nxt = strdup(path);
    g_equus_log_path = nxt;
  }

  /*
   * PQ:TODO: not thread safe. Don't do this from lots of other threads.
   */
  if (oldstr != NULL) {
    free(oldstr);
  }
  return equus_log_rotate();
}

void equus_log_level_set(equus_log_level_e level)
{
  g_equus_log_level = level;
}

equus_log_level_e equus_log_level_get()
{
  return g_equus_log_level;
}

/* Logs a completely formated string into the current log file.
 * Line must include newline, and is written regardless of the log level.
 */
static void equus_log_buf(const char *str, size_t len)
{
  /**
   * TOOD: log to file
   * TODO: rotate log file on sigup
   * TODO: write trailing newline
   */
  if (g_equus_log_fp == NULL) {
    g_equus_log_fp = stderr;
  }
  fwrite(str, 1, strlen(str), g_equus_log_fp);
  fflush(g_equus_log_fp);
}

/* Prepends date, level, and appends newline*/
/* TODO: should this be exposed to lua? */
void equus_log(equus_log_level_e level, const char *str)
{
  if (equus_log_level_get() < level) {
    return;
  }
#ifdef USE_EVENT_LOG
  else if (g_equus_log_fp == NULL) {
    /* TODO: loglevel to eventlog type and messages db file */
    g_equus_log_handle = OpenEventLog(NULL, "Cloudkick Agent Service"); /* pretty name for event log */
    ReportEventA(g_equus_log_handle, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, &str, NULL);
    CloseEventLog(g_equus_log_handle);
  }
#endif
  else {
    time_t t;
    char buf[4000] = {0};
    size_t slen = 0;
    size_t blen = 0;
    size_t availlen;
    struct tm tm;
    struct tm *ptm;
    const char *llstr = NULL;

    slen = strlen(str);
    t = time(NULL);

#ifdef _WIN32
    /* modern version of msvc use a thread-local buffer for gmtime_r */
    ptm = gmtime(&t);
    memcpy(&tm, ptm, sizeof(struct tm));
    ptm = &tm;
    {
      char *p = asctime(ptm);
      memcpy(&buf[0], p, 24);
    }
#else
    ptm = gmtime_r(&t, &tm);
    /* TODO: use a different time format ?*/
    asctime_r(ptm, &buf[0]);
#endif
    blen += 24;
    switch (level) {
      case EQUUS_LOG_CRITICAL:
        llstr = " CRT: ";
        break;
      case EQUUS_LOG_ERRORS:
        llstr = " ERR: ";
        break;
      case EQUUS_LOG_WARNINGS:
        llstr = " WRN: ";
        break;
      case EQUUS_LOG_INFO:
        llstr = " INF: ";
        break;
      case EQUUS_LOG_DEBUG:
        llstr = " DBG: ";
        break;
      default:
        llstr = " UNK: ";
        break;
    }

    memcpy(&buf[0]+blen, llstr, 6);
    blen += 6;

    availlen = sizeof(buf) - blen - 2;

    if (slen > availlen) {
      slen = availlen;
    }

    memcpy(&buf[0]+blen, str, slen);
    blen += slen;

    memcpy(&buf[0]+blen, "\n\0", 2);
    blen += 2;
    equus_log_buf(&buf[0], blen);
    if (level == EQUUS_LOG_CRITICAL &&
        g_equus_log_fp != stderr) {
      fwrite(&buf[0], 1, blen, stderr);
      fflush(stderr);
    }
  }
}

void equus_log_fmtv(equus_log_level_e level, const char *fmt, va_list ap)
{
  if (equus_log_level_get() >= level) {
    char buf[4000];
    int rv = vsnprintf(&buf[0], sizeof(buf), fmt, ap);
    if (rv >= 0) {
      /* PQ:TODO: This is not as efficient as it could be, we could build
       * the log line inline here with a little code refactoring, rather than
       * an inline snprintf/calling out to the string based logger.
       */
      equus_log(level, buf);
    }
  }
}

void equus_log_fmt(equus_log_level_e level, const char* fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
  equus_log_fmtv(level, fmt, ap);
  va_end(ap);
}

void equus_log_criticalf(const char *fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
  equus_log_fmtv(EQUUS_LOG_CRITICAL, fmt, ap);
  va_end(ap);
}

void equus_log_errorf(const char *fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
  equus_log_fmtv(EQUUS_LOG_ERRORS, fmt, ap);
  va_end(ap);
}

void equus_log_warningf(const char *fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
  equus_log_fmtv(EQUUS_LOG_WARNINGS, fmt, ap);
  va_end(ap);
}

void equus_log_infof(const char *fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
  equus_log_fmtv(EQUUS_LOG_INFO, fmt, ap);
  va_end(ap);
}

void equus_log_debugf(const char *fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
  equus_log_fmtv(EQUUS_LOG_DEBUG, fmt, ap);
  va_end(ap);
}

void equus_log_critical(const char *str)
{
  equus_log(EQUUS_LOG_CRITICAL, str);
}

void equus_log_error(const char *str)
{
  equus_log(EQUUS_LOG_ERRORS, str);
}

void equus_log_warning(const char *str)
{
  equus_log(EQUUS_LOG_WARNINGS, str);
}

void equus_log_info(const char *str)
{
  equus_log(EQUUS_LOG_INFO, str);
}

void equus_log_debug(const char *str)
{
  equus_log(EQUUS_LOG_DEBUG, str);
}


/* Helper for hacks for deamonizing */
int equus_shutdown_stdio()
{
  if (freopen("/dev/null", "r", stdin) == NULL) {
    return errno;
  }
  if (freopen("/dev/null", "w", stdout) == NULL) {
    return errno;
  }
  if (freopen("/dev/null", "w", stderr) == NULL) {
    return errno;
  }
  return 0;
}



typedef struct eqr_list_t eqr_list_t;

struct eqr_list_t {
  equus_result_t *res;
  eqr_list_t *next;
};

eqr_list_t *head = NULL;
static void push_rentry(equus_result_t* res)
{
  eqr_list_t *e;
  MTX_LOCK(resmtx);
  e = malloc(sizeof(eqr_list_t));
  e->res = res;
  e->next = head;
  head = e;
  MTX_UNLOCK(resmtx);
}

static void pop_rentry(equus_result_t** res)
{
  eqr_list_t *e;
  MTX_LOCK(resmtx);

  if (head == NULL) {
    *res = NULL;
    MTX_UNLOCK(resmtx);
    return;
  }

  e = head;
  *res = e->res;
  head = e->next;

  MTX_UNLOCK(resmtx);
}

void equus_push_result(const char *data, int len)
{
  char *tmp;
  equus_result_t *res;
  logInfo("Pushing %d bytes", len);
  res = malloc(sizeof(equus_result_t));
  tmp = malloc(len+1);
  memcpy(tmp, data, len);
  tmp[len] = '\0';
  res->data = tmp;
  res->length = len;
  push_rentry(res);
}

equus_result_t *equus_pop_result()
{
  equus_result_t *res = NULL;
  pop_rentry(&res);
  return res;
}

void equus_free_result(equus_result_t *res)
{
  if (res != NULL) {
    free((char*)res->data);
    free(res);
  }
}


const char* p_platform()
{
  return EQUUS_PLATFORM;
}

int p_is_windows()
{
#ifdef _WIN32
  return 1;
#else
  return 0;
#endif
}

int p_is_unix()
{
  return !p_is_windows();
}

int p_is_darwin()
{
#ifdef __APPLE__
  return 1;
#else
  return 0;
#endif
}

int p_is_freebsd()
{
#ifdef __FreeBSD__
  return 1;
#else
  return 0;
#endif
}

int p_is_openbsd()
{
#ifdef __OpenBSD__
  return 1;
#else
  return 0;
#endif
}

int p_is_netbsd()
{
#ifdef __NetBSD__
  return 1;
#else
  return 0;
#endif
}

int p_is_solaris()
{
#ifdef __sun
  return 1;
#else
  return 0;
#endif
}

int p_is_linux()
{
#ifdef __linux__
  return 1;
#else
  return 0;
#endif
}


int g_equus_run_count = 0;
#ifdef _WIN32
int g_equus_win_service = 0;
#endif

static int g_equus_restart = 0;

int equus_restart_get()
{
  return g_equus_restart;
}

void equus_restart_set(int i)
{
  g_equus_restart = i;
}


/*
 * libev win32 compatibility cruft (_not_ a backend)
 *
 * Copyright (c) 2007,2008,2009 Marc Alexander Lehmann <libev@schmorp.de>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modifica-
 * tion, are permitted provided that the following conditions are met:
 *
 *   1.  Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *
 *   2.  Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
 * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
 * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
 * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
 * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Alternatively, the contents of this file may be used under the terms of
 * the GNU General Public License ("GPL") version 2 or any later version,
 * in which case the provisions of the GPL are applicable instead of
 * the above. If you wish to allow the use of your version of this file
 * only under the terms of the GPL and not to allow others to use your
 * version of this file under the BSD license, indicate your decision
 * by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL. If you do not delete the
 * provisions above, a recipient may use your version of this file under
 * either the BSD or the GPL.
 */

#ifdef _WIN32
/* oh, the humanity! */
int pipe_win32 (int filedes [2])
{
  struct sockaddr_in addr = { 0 };
  int addr_size = sizeof (addr);
  struct sockaddr_in adr2;
  int adr2_size = sizeof (adr2);
  SOCKET listener;
  SOCKET sock [2] = { -1, -1 };

  if ((listener = socket (AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
    return -1;

  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
  addr.sin_port = 0;

  if (bind (listener, (struct sockaddr *)&addr, addr_size))
    goto fail;

  if (getsockname (listener, (struct sockaddr *)&addr, &addr_size))
    goto fail;

  if (listen (listener, 1))
    goto fail;

  if ((sock [0] = socket (AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
    goto fail;

  if (connect (sock [0], (struct sockaddr *)&addr, addr_size))
    goto fail;

  if ((sock [1] = accept (listener, 0, 0)) < 0)
    goto fail;

  /* windows vista returns fantasy port numbers for sockets:
   * example for two interconnected tcp sockets:
   *
   * (Socket::unpack_sockaddr_in getsockname $sock0)[0] == 53364
   * (Socket::unpack_sockaddr_in getpeername $sock0)[0] == 53363
   * (Socket::unpack_sockaddr_in getsockname $sock1)[0] == 53363
   * (Socket::unpack_sockaddr_in getpeername $sock1)[0] == 53365
   *
   * wow! tridirectional sockets!
   *
   * this way of checking ports seems to work:
   */
  if (getpeername (sock [0], (struct sockaddr *)&addr, &addr_size))
    goto fail;

  if (getsockname (sock [1], (struct sockaddr *)&adr2, &adr2_size))
    goto fail;

  errno = WSAEINVAL;
  if (addr_size != adr2_size
      || addr.sin_addr.s_addr != adr2.sin_addr.s_addr /* just to be sure, I mean, it's windows */
      || addr.sin_port        != adr2.sin_port)
    goto fail;

  closesocket (listener);

#if EV_SELECT_IS_WINSOCKET
  filedes [0] = EV_WIN32_HANDLE_TO_FD (sock [0]);
  filedes [1] = EV_WIN32_HANDLE_TO_FD (sock [1]);
#else
  /* when select isn't winsocket, we also expect socket, connect, accept etc.
   * to work on fds */
  filedes [0] = sock [0];
  filedes [1] = sock [1];
#endif

  return 0;

fail:
  closesocket (listener);

  if (sock [0] != INVALID_SOCKET) closesocket (sock [0]);
  if (sock [1] != INVALID_SOCKET) closesocket (sock [1]);

  return -1;
}

#endif

#ifdef USE_SIGAR
sigar_t * sigar_create(void)
{
  sigar_t * si = NULL;

  if (si)
    return si;

  if (sigar_open(&si) != SIGAR_OK)
    si = NULL;

  return si;
}

int sigar_destroy(sigar_t *si)
{
  if (!si)
    return NULL;

  return sigar_close(si);
}

#endif

// Memory debugging
#if defined(_WIN32) && defined(_DEBUG) && defined(_MSC_VER)
static _CrtMemState state1;
static _CrtMemState state2;
static _CrtMemState state3;
#endif


#ifdef _WIN32
void win32_mem_checkpoint_init(void)
{
#if defined(_WIN32) && defined(_DEBUG) && defined(_MSC_VER)
  _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
  _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT );
  _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );
  _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT );
  _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
  _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT );
  _CrtMemCheckpoint(&state2);
#endif
}

void win32_mem_checkpoint(void)
{
  char *addr;
#if defined(_WIN32) && defined(_DEBUG) && defined(_MSC_VER)
  state1 = state2;
  _CrtMemCheckpoint(&state2);
  _CrtMemDumpStatistics(&state2);
  printf("=======\n");
#endif
  addr = malloc(8);
  printf("addr = 0x%x\n", addr);
  if (addr)
    free(addr);
}

void win32_mem_difference(void)
{
#if defined(_WIN32) && defined(_DEBUG) && defined(_MSC_VER)
  if (_CrtMemDifference(&state3, &state1, &state2)) {
    printf("checkpoint memory difference:\n");
    _CrtMemDumpStatistics(&state3);
  printf("=======\n");
  }
#endif
}

void win32_dumpmemoryleaks(void)
{
#if defined(_WIN32) && defined(_DEBUG) && defined(_MSC_VER)
  _CrtDumpMemoryLeaks();
#endif
}

int win32_mem_values(void)
{
#if defined(_WIN32) && defined(_DEBUG) && defined(_MSC_VER)
  return 0;
#else
  return 0;
#endif
}

unsigned win32_getprocmemory(void)
{
  unsigned bytes_used = 0;
#if defined(_WIN32) && defined(_MSC_VER)
  PROCESS_MEMORY_COUNTERS pmc;
  HANDLE cur_proc = GetCurrentProcess();

  if ( GetProcessMemoryInfo(cur_proc, &pmc, sizeof(pmc)) ) {
/*
    printf( "\tPageFaultCount: %d\n", pmc.PageFaultCount / 1024 );

    printf( "\tPeakWorkingSetSize: %d\n", pmc.PeakWorkingSetSize / 1024 );
    printf( "\tWorkingSetSize: %d\n", pmc.WorkingSetSize / 1024 );

    printf( "\tPagefileUsage: %d\n", pmc.PagefileUsage / 1024 );
    printf( "\tPeakPagefileUsage: %d\n", pmc.PeakPagefileUsage / 1024 );
*/
    bytes_used = pmc.WorkingSetSize + pmc.PagefileUsage;
/*
    printf("bytes used: %d\n", bytes_used);
*/
    if (pmc.WorkingSetSize > 30000000) {
      printf("terminate because of size\n");
      exit(1);
    }
  }

#endif
  return bytes_used;
}
#endif
